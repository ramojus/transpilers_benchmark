<?php
class A {
    public function execute($foo) { }
}
class B extends A {
    public function execute() { }
    public ?string $name;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    /**
     * @param mixed $param
     */
    public function run($param) {
        switch ($input) {
            case Lexer::T_SELECT:
                $statement = 'select';
                break;
            default:
            $statement = 'error';
        }
        $isMatch = substr($haystack, -strlen($needle)) === $needle;
        $isMatch = substr($haystack, -9) === 'hardcoded';
        $isMatch = substr($haystack, 0, strlen($needle)) === $needle;
        try { } catch (Throwable $notUsedThrowable) { }
        return get_class($object);
        return $this::class;
        return is_object($value) ? get_class($value) : gettype($value);
        return strpos('abc', 'a') !== false;
    }
    final private function getter() { }
    public function __toString() {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) { }
}
class B extends A {
    public function execute() { }
    public ?string $name;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    /**
     * @param mixed $param
     */
    public function run($param) {
        switch ($input) {
            case Lexer::T_SELECT:
                $statement = 'select';
                break;
            default:
            $statement = 'error';
        }
        $isMatch = substr($haystack, -strlen($needle)) === $needle;
        $isMatch = substr($haystack, -9) === 'hardcoded';
        $isMatch = substr($haystack, 0, strlen($needle)) === $needle;
        try { } catch (Throwable $notUsedThrowable) { }
        return get_class($object);
        return $this::class;
        return is_object($value) ? get_class($value) : gettype($value);
        return strpos('abc', 'a') !== false;
    }
    final private function getter() { }
    public function __toString() {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) { }
}
class B extends A {
    public function execute() { }
    public ?string $name;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    /**
     * @param mixed $param
     */
    public function run($param) {
        switch ($input) {
            case Lexer::T_SELECT:
                $statement = 'select';
                break;
            default:
            $statement = 'error';
        }
        $isMatch = substr($haystack, -strlen($needle)) === $needle;
        $isMatch = substr($haystack, -9) === 'hardcoded';
        $isMatch = substr($haystack, 0, strlen($needle)) === $needle;
        try { } catch (Throwable $notUsedThrowable) { }
        return get_class($object);
        return $this::class;
        return is_object($value) ? get_class($value) : gettype($value);
        return strpos('abc', 'a') !== false;
    }
    final private function getter() { }
    public function __toString() {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) { }
}
class B extends A {
    public function execute() { }
    public ?string $name;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    /**
     * @param mixed $param
     */
    public function run($param) {
        switch ($input) {
            case Lexer::T_SELECT:
                $statement = 'select';
                break;
            default:
            $statement = 'error';
        }
        $isMatch = substr($haystack, -strlen($needle)) === $needle;
        $isMatch = substr($haystack, -9) === 'hardcoded';
        $isMatch = substr($haystack, 0, strlen($needle)) === $needle;
        try { } catch (Throwable $notUsedThrowable) { }
        return get_class($object);
        return $this::class;
        return is_object($value) ? get_class($value) : gettype($value);
        return strpos('abc', 'a') !== false;
    }
    final private function getter() { }
    public function __toString() {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) { }
}
class B extends A {
    public function execute() { }
    public ?string $name;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    /**
     * @param mixed $param
     */
    public function run($param) {
        switch ($input) {
            case Lexer::T_SELECT:
                $statement = 'select';
                break;
            default:
            $statement = 'error';
        }
        $isMatch = substr($haystack, -strlen($needle)) === $needle;
        $isMatch = substr($haystack, -9) === 'hardcoded';
        $isMatch = substr($haystack, 0, strlen($needle)) === $needle;
        try { } catch (Throwable $notUsedThrowable) { }
        return get_class($object);
        return $this::class;
        return is_object($value) ? get_class($value) : gettype($value);
        return strpos('abc', 'a') !== false;
    }
    final private function getter() { }
    public function __toString() {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) { }
}
class B extends A {
    public function execute() { }
    public ?string $name;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    /**
     * @param mixed $param
     */
    public function run($param) {
        switch ($input) {
            case Lexer::T_SELECT:
                $statement = 'select';
                break;
            default:
            $statement = 'error';
        }
        $isMatch = substr($haystack, -strlen($needle)) === $needle;
        $isMatch = substr($haystack, -9) === 'hardcoded';
        $isMatch = substr($haystack, 0, strlen($needle)) === $needle;
        try { } catch (Throwable $notUsedThrowable) { }
        return get_class($object);
        return $this::class;
        return is_object($value) ? get_class($value) : gettype($value);
        return strpos('abc', 'a') !== false;
    }
    final private function getter() { }
    public function __toString() {
        return 'I can stringz';
    }
}
