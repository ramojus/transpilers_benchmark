<?php
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try {
        } catch (Throwable) {
        }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) { }
    public ?string $name = null;
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
        $isMatch = str_ends_with($haystack, $needle);
        $isMatch = str_ends_with($haystack, 'hardcoded');
        $isMatch = str_starts_with($haystack, $needle);
        try { } catch (Throwable) { }
        return $object::class;
        return static::class;
        return get_debug_type($value);
        return str_contains('abc', 'a');
    }
    private function getter() { }
    public function __toString(): string {
        return 'I can stringz';
    }
}
class A {
    public function execute($foo) {
    }
}
class B extends A implements \Stringable {
    public function execute($foo) {
    }
    public float $price;
    public function __construct(float $price = 0.0) {
    }
    public function run(mixed $param) {
        $statement = match ($input) {
            Lexer::T_SELECT => 'select',
            default => 'error',
        };
    }
    private function getter() {
    }
    public function __toString(): string
    {
        return '';
    }
}
